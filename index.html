<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="slixurd" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> slixurd </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">slixurd</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            <i class="menu-item-icon icon-about"></i> <br />
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      
        

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/10/ElasticSearchQueryAndFilter/">
                ElasticSearch的搜索和过滤
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-10
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/10/ElasticSearchQueryAndFilter/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/09/10/ElasticSearchQueryAndFilter/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="查询">查询</h1><h2 id="Match">Match</h2><p>Match查询接收一个类型为text/numerics/dates的值，分析后返回一个查询，例如 <code>{&quot;match&quot;:{ k:v } }</code>。</p>
<p>默认的match查询是bool类型的，这意味着match提供的字符串会被分析器拆分成子串，然后构造成Bool查询,例如quick Fox会被拆成quick和fox。<br>因此match查询提供了一个operator参数，可以用于设置or/and来控制bool查询，默认是or。另外还有一个 minimum_should_match参数来控制should子句应该匹配的最少的数目。<br>例如有内容为Quick Fox的文档(并且不是Not_Analyzed的域)，当提供v为fox one的条件搜索时，可以匹配结果，因为倒排链表保存的就是fox，而且match的内容fox one会被拆分成fox和one去匹配。</p>
<p>Match查询需要和Term查询区分，Term查询不会分析单词串，如果查找Fox，那么在倒排索引中就找不到数据。</p>
<p>zero_terms_query参数有none和all两个值，表示当所有词被分析器移除时（例如to be or not to be）查询应该返回所有文档还是什么都不返回。</p>
<h2 id="Multi_match查询">Multi_match查询</h2><p>基于query查询提供的查询。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">query</span>: <span class="string">v</span></span><br><span class="line"><span class="attribute">fields</span>: <span class="string">[k1,k2]</span></span><br></pre></td></tr></table></figure></p>
<p>和query不同的是，fields的参数可以提供通配符支持，比如fields可以填入*name用于匹配last_name, first_name。由于query需要计算评分，所以这里可以指定某个field的权重。例如subject^3表示subject的权重为其余field的3倍。multi_match实际上会生成在dis_max查询下的多个match查询。可以通过把use_dis_max设为false来将dis_max转换为bool查询。</p>
<p>multi_match的type参数可以决定查询结果的排序。有以下几个值：</p>
<ol>
<li>best_fields:匹配所有field，但是用得分最高的match查询来决定整个查询的分数。tie_breaker参数可以让其他field的_score也参与计算。最终计算为Best_score + SUM _score * tie_breaker。</li>
<li>most_fields:匹配所有field，然后加权平均，如果没有指定权重就直接使用算数平均值</li>
</ol>
<h2 id="Term查询">Term查询</h2><p>这个查询仅仅匹配给定字段中含有关键字的文档，而且是未经分析的关键字。Term查询还可以指定加权属性Boost(float)。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"term"</span><span class="symbol">:</span>&#123;</span><br><span class="line">     <span class="string">"k"</span><span class="symbol">:</span>&#123;</span><br><span class="line">          <span class="string">"value"</span><span class="symbol">:v</span>,</span><br><span class="line">          <span class="string">"boost"</span><span class="symbol">:</span><span class="number">10.0</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"term"</span><span class="symbol">:</span>&#123;<span class="symbol">k:</span>v&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Terms查询">Terms查询</h2><p>和Term查询一样，关键字不予分析。提供多个关键字所有，可以配置minimum_match属性，表示至少有minimum_match个词条应该被匹配。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"terms"</span>:&#123;</span><br><span class="line">     k:[<span class="literal">v1</span>,<span class="literal">v2</span>],</span><br><span class="line">     <span class="string">"minimum_match"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Common查询">Common查询</h2><p>主要解决因为高频词（例如stop words)造成的查询问题，例如一个关键字a and b，如果使用正常的match查询，那么and被分析器拆开单独匹配文档时会匹配到大量的文档。因此需要对这类高频词进行处理。这里提供一个cutoff_frequency，定义一个值，来决定什么样的词是低频词，例如提供0.01，表示词频低于1%的为低频词。另外还可以提供high_freq_operator/low_freq_operator来决定词条间的关系，可以设置为and，or，例如high_freq_operator:and表示高频词组需要都出现，文档才能被匹配。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">common</span>:&#123;</span><br><span class="line">     <span class="tag">k</span>:&#123;</span><br><span class="line">          <span class="attribute">query</span>:v,</span><br><span class="line">          <span class="attribute">cutoff_frequency</span>:<span class="number">0.01</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Match_phrase查询">Match_phrase查询</h2><p>类似于match查询，不过不需要指定operator。而是以slop的值来构建短语查询。<br>当slop为1时，表示词条和文档之间能有多少个未知词条。默认为0.表示 a b不能和a and b匹配。</p>
<h2 id="Query_String查询">Query String查询</h2><p>Lucene式查询。<code>query_string:{query: +k:v^10 -k:v +k:(+v +v) +v}</code>。可以指定不带k时默认查询的k，default_field默认为_all。<br>lowercase_expand_terms表示是否需要将词条转换为小写再来查找，默认为true。<br>可以指定查询的fields。另外还有一个use_dis_max参数，值为bool。<br>Dis表示Disjunction，可以跨多个字段查询，每个字段有不同权重。Max表示对给定词条，直邮最高分的才在最后评分中，而不是简单求和。</p>
<p>此外还有一个simple_query_string。这个查询在query的参数有无效部分的情况下，会忽视无效部分，而不会抛出异常。</p>
<h2 id="IDS查询">IDS查询</h2><p>标志符查询。<br><code>ids:{ values: [id,id,id….] }</code><br>返回匹配这些id的文档。可以制定type。</p>
<h2 id="Prefix查询">Prefix查询</h2><p>前缀查询。查询字符串前缀。查询的字符串不会被分析，所以quick Fox不可以被Fo匹配。</p>
<h2 id="Fuzzy查询">Fuzzy查询</h2><p>模糊查询。可以让用户以crme查出crime这样的文档<br>value提供查询的词条。min_similarity表示最小相似度，对于字符串而言这应该在0-1之间，对数值而言，这是差值的绝对值，例如最小相似度是3，对于值20，可以匹配17-23之间的值，对日期而言，可以设为1d,1m,1s，表示时间相差长度。</p>
<h2 id="Wildcard查询">Wildcard查询</h2><p>通配符查询。支持通配符<em>,?。</em>匹配任意字符串,?匹配任意字符。</p>
<h2 id="Range查询">Range查询</h2><p>查询一个字段在某个范围内的文档。使用gte,lte,le,te作为参数，具体范围作为值。</p>
<h2 id="Dis_Max查询">Dis Max查询</h2><p>最大分查询。<br>和multi_match的best_field一样。用得分最高的match查询来决定整个查询的分数。tie_breaker参数可以让其他field的_score也参与计算。最终计算为Best_score + SUM _score * tie_breaker。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"query"</span>: &#123;</span><br><span class="line">     <span class="string">"dis_max"</span>: &#123;</span><br><span class="line">          <span class="string">"tie_breaker"</span>: <span class="number">0.7</span>,</span><br><span class="line">          <span class="string">"boost"</span>: <span class="number">1.2</span>,</span><br><span class="line">          <span class="string">"queries"</span>: <span class="literal">[]</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正则查询">正则查询</h2><p>提供正则表达式查询。查询词条可以包含正则表达式。</p>
<h2 id="Bool查询">Bool查询</h2><p>提供should,must,must_not的子句。</p>
<h2 id="Boosting查询">Boosting查询</h2><p>加权查询。<br>提供positive和negative查询。positive部分不改变_score，negative部分降低_score。需要提供negative_boost参数表示降分的程度。</p>
<h1 id="过滤">过滤</h1><p>查询用于使用不同条件得到结果及其评分，然而要在不影响评分的情况下获得子集，就需要过滤器。<br>过滤器不需要耗费CPU计算评分，因此相对速度比较快，而且过滤能够被索引。</p>
<p>过滤有两个大类型。<br>一个是post_filter,和query同级，执行操作时先通过query查询文档，再使用过滤器过滤。<br>而另外一种filtered过滤，内部包含query和filter，会先过滤再查询。性能稍微好一点。</p>
<p>过滤器类型大体和查询相似。</p>
<h2 id="Range过滤器。">Range过滤器。</h2><p>用于过滤范围。</p>
<h2 id="Exists_过滤器。">Exists 过滤器。</h2><p>提供一个field作为参数，要求返回的文档必须有该field</p>
<h2 id="Missing过滤器">Missing过滤器</h2><p>和exists相反，要求文档必须没有field字段。<br>另外还提供null_value参数，用于判断什么是“没有”该字段，例如null_value为0，表示所有field为0的文档或者没有该field的文档都会被返回。existence表示需要检查field的值，和null_value需要一起使用。</p>
<h2 id="Script过滤器">Script过滤器</h2><p>用于计算过滤。script: <code>&quot;1000 - doc[&#39;num&#39;] &gt; 100&quot;</code>。找出1000-num大于100的文档。</p>
<h2 id="Type过滤器">Type过滤器</h2><p><code>type: { value : FIELD }</code><br>限制返回的文档的TYPE</p>
<h2 id="Limit过滤器">Limit过滤器</h2><p>限定单个shard返回的文档数目。</p>
<h2 id="And/Or/Not">And/Or/Not</h2><p>可以使用逻辑过滤器，内部可以套嵌多个过滤器。</p>
<p>其余可以使用的查询都可以套嵌在Query中，功能一样，只是不影响评分。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


      
    
      
        

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/08/24/Elastic-Search-Java-API-Section-1/">
                Elastic Search Java API Section 1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-08-24
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/08/24/Elastic-Search-Java-API-Section-1/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/08/24/Elastic-Search-Java-API-Section-1/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="配置">配置</h1><p>Maven配置。现在es的最新的release版本为1.7.1<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">version</span>&gt;</span>$&#123;es.version&#125;<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="客户端类型">客户端类型</h1><h2 id="Node_Client">Node Client</h2><p>加入ES集群中，但是不持有数据，不会被选举成为Master节点(作为clients时)，能够获取整个集群状态，执行API时可以减少一次网络跳跃。<br>因为Node Client拥有集群的数据，操作可以自动路由到操作最终会被执行的节点，而不需要制定double hop。<br>适用于客户端中需要少量生存时间较长的连接，并且Node Client相比Transport Client更加效率。</p>
<p>通过cluster.name加入集群。可以直接配置resoures/elasticsearch.yml设置cluster.name，也可以使用代码加入特定集群。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node node = NodeBuilder.nodeBuilder<span class="params">()</span>.clusterName<span class="params">(<span class="string">"yourclustername"</span>)</span>.node<span class="params">()</span>; Client client = node.client<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果希望这个节点不保存数据，不被选为Master，需要指定<code>nodeBuilder.client(true)</code>。或者将node.data设置为false。<br>data和client的区别在于，data只是不保存数据，但是可以被选为master，client不保存数据，也不会被选为master。<br>在需要进行单元测试时，可以将node设置为local模式。运行在本地JVM上，本地的两个服务可以组成一个集群。</p>
<h2 id="Transport_Client">Transport Client</h2><p>不加入集群中，只有通信的作用。用于将应用和集群解耦，用于快速创建和销毁连接，更加轻量级。<br>在没有修改集群名字的情况下可以直接使用TransportClient。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Client client = new TransportClient<span class="params">()</span></span><br><span class="line">        .addTransportAddress<span class="params">(new InetSocketTransportAddress<span class="params">(<span class="string">"host1"</span>, <span class="number">9300</span>)</span>)</span></span><br><span class="line">        .addTransportAddress<span class="params">(new InetSocketTransportAddress<span class="params">(<span class="string">"host2"</span>, <span class="number">9300</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// on shutdown</span></span><br><span class="line">client.close<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果集群名字不是默认的”elasticsearch”，就需要修改yml配置或者在代码中配置。否则会提示None of the configured nodes are available<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Settings setting = ImmutableSettings.settingsBuilder<span class="params">()</span>.put<span class="params">(<span class="string">"cluster.name"</span>, <span class="string">"slixurd"</span>)</span>.build<span class="params">()</span>;</span><br><span class="line">Client client = new TransportClient<span class="params">(setting)</span></span><br><span class="line">     .addTransportAddress<span class="params">(new InetSocketTransportAddress<span class="params">(<span class="string">"172.16.63.129"</span>, <span class="number">9300</span>)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="客户端操作">客户端操作</h1><h2 id="索引">索引</h2><p>增加一个文档实际上就是将文档添加到一个特定的索引上。<br>生成Json文档有如下4种方式。</p>
<ol>
<li>手写Json，用String自己生成一个Json。</li>
<li>使用Map，正如一般的kv对一样，该怎么写怎么写。</li>
<li><p>Jackson，可以简单的将bean序列化为Json。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">ObjectMapper</span> mapper = new ObjectMapper()<span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span>json = mapper.writeValueAsString( <span class="keyword">bean </span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Elasticsearch Helper</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XContentBuilder</span> builder = <span class="type">XContentFactory</span>.jsonBuilder<span class="literal">()</span></span><br><span class="line">    .startObject<span class="literal">()</span></span><br><span class="line">        .field(<span class="string">"k"</span>, <span class="string">"v"</span>)</span><br><span class="line">    .endObject<span class="literal">()</span></span><br><span class="line"><span class="type">String</span> json = builder.<span class="built_in">string</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>新建的API为：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IndexRequestBuilder prepareIndex(<span class="keyword">String</span> <span class="keyword">index</span>, <span class="keyword">String</span> <span class="keyword">type</span>, @Nullable <span class="keyword">String</span> id);</span><br><span class="line">IndexRequestBuilder prepareIndex(<span class="keyword">String</span> <span class="keyword">index</span>, <span class="keyword">String</span> <span class="keyword">type</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以通过client使用prepareIndex<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse response = client.prepareIndex<span class="params">(<span class="string">"twitter"</span>,<span class="string">"tweet"</span>,<span class="string">"3"</span>)</span>.setSource<span class="params">(json)</span>.execute<span class="params">()</span>.actionGet<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>SetSource函数可以接收一个Mapper，或者一个XContentBuilder,也可以接收一个字符串。<br>execute返回一个future的子类，actionGet得到ES包装后的一个Response。这个IndexResponse中包含index,id,type,version,created五个属性。</p>
<h2 id="获取">获取</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetResponse</span> response = client.prepareGet(index, <span class="typedef"><span class="keyword">type</span>, id).execute<span class="container">()</span>.actionGet<span class="container">()</span>;</span></span><br><span class="line"><span class="type">GetResponse</span> response = client.prepareGet(index, <span class="typedef"><span class="keyword">type</span>, id).setOperationThreaded<span class="container">(<span class="title">false</span>)</span>.execute<span class="container">()</span>.actionGet<span class="container">()</span>;</span></span><br></pre></td></tr></table></figure>
<p>通过GetResponse保存获得的数据。prepareGet检索对应的文档。还可以使用setOperationThreaded控制执行的线程，默认为true，执行在其他线程上。</p>
<h2 id="删除">删除</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteResponse</span> response = client.prepareDelete(index, <span class="typedef"><span class="keyword">type</span>, id).execute<span class="container">()</span>.actionGet<span class="container">()</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="修改">修改</h2><p>通过UpdateRequest创建Request，然后使用client的update函数更新<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UpdateRequest updateRequest = new UpdateRequest<span class="params">(index, type, id)</span>;</span><br><span class="line">updateRequest.doc<span class="params">(jsonBuilder<span class="params">()</span>.startObject<span class="params">()</span>.field<span class="params">(key, value)</span>.endObject<span class="params">()</span>)</span>;</span><br><span class="line">client.update<span class="params">(updateRequest)</span>.get<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用prepareUpdate函数,get相当于execute().actionGet()。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateResponse</span> response = client.prepareUpdate(index, <span class="typedef"><span class="keyword">type</span>, id).setDoc<span class="container">(<span class="title">doc</span>)</span>.get<span class="container">()</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>API还提供了一个类似Mysql的INSERT … ON DUPLICATE KEY UPDATE函数 upsert。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UpdateResponse response = client.prepareUpdate<span class="params">(index, type, id)</span></span><br><span class="line">     .setUpsert<span class="params">(XContentFactory.jsonBuilder<span class="params">()</span>.startObject<span class="params">()</span>.field<span class="params">(k1, v1)</span>.endObject<span class="params">()</span>)</span></span><br><span class="line">     .setDoc<span class="params">(XContentFactory.jsonBuilder<span class="params">()</span>.startObject<span class="params">()</span>.field<span class="params">(k1, v2)</span>.endObject<span class="params">()</span>)</span>.get<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>当index，type，id三者决定的唯一文档不存在时，那么插入k1，v1的这个对象，如果文档存在，则把k1更新为v2.</p>
<h2 id="Bulk_API">Bulk API</h2><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BulkRequestBuilder bulkRequest = client.prepareBulk<span class="params">()</span>;</span><br><span class="line">bulkRequest.add<span class="params">(client.prepareIndex<span class="params">(index, type, id)</span>.setSource<span class="params">(doc1)</span>)</span>;</span><br><span class="line">bulkRequest.add<span class="params">(deleteRequest)</span>;</span><br><span class="line">BulkResponse bulkResponse = bulkRequest.execute<span class="params">()</span>.actionGet<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>BulkResponse内部包含一个数组，为每一个失败的请求保留一份记录。<br>可以用于批量更新，批量删除，批量索引。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


      
    
      
        

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/08/23/Elastic-Search基本知识/">
                Elastic Search基本知识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-08-23
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/08/23/Elastic-Search基本知识/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/08/23/Elastic-Search基本知识/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="安装">安装</h1><p>下载安装文件</p>
<pre><code>wget <span class="symbol">https:</span>/<span class="regexp">/download.elastic.co/elasticsearch</span><span class="regexp">/elasticsearch/elasticsearch</span>-<span class="number">1.7</span>.<span class="number">1</span>.tar.gz
</code></pre><p>解压</p>
<pre><code><span class="tag">tar</span> <span class="tag">xvf</span> <span class="tag">elasticsearch-1</span><span class="class">.7</span><span class="class">.1</span><span class="class">.tar</span><span class="class">.gz</span>
</code></pre><p>安装管理软件Marvel</p>
<pre><code>.<span class="regexp">/bin/</span>plugin -i elasticsearch<span class="regexp">/marvel/</span>latest
</code></pre><h1 id="客户端">客户端</h1><h2 id="node_client">node client</h2><p>节点客户端以无数据节点身份加入集群，本身不存储诗句，但是知道数据的位置，并且能够转发请求道对应节点上。</p>
<h2 id="transport_client">transport client</h2><p>不加入集群，只转发请求。<br>客户端都是以9300号端口交互，使用私有传输协议，ElasticSearch Transport Protocol。<br>http模式以9200端口交互。</p>
<h1 id="操作">操作</h1><pre><code>curl -X<span class="tag">&lt;<span class="title">VERB</span>&gt;</span> '<span class="tag">&lt;<span class="title">PROTOCOL</span>&gt;</span>://<span class="tag">&lt;<span class="title">HOST</span>&gt;</span>/<span class="tag">&lt;<span class="title">PATH</span>&gt;</span>?<span class="tag">&lt;<span class="title">QUERY_STRING</span>&gt;</span>' -d '<span class="tag">&lt;<span class="title">BODY</span>&gt;</span>'
</code></pre><p>VERB包括 GET,POST,PUT,HEAD,DELETE<br>BODY为JSON格式的请求主体。</p>
<pre><code>Relational DB <span class="subst">-&gt; </span>Databases <span class="subst">-&gt; </span>Tables <span class="subst">-&gt; </span><span class="keyword">Rows</span> <span class="subst">-&gt; </span>Columns Elasticsearch <span class="subst">-&gt; </span>Indices   <span class="subst">-&gt; </span>Types  <span class="subst">-&gt; </span>Documents <span class="subst">-&gt; </span>Fields
</code></pre><p>关系类比。</p>
<p>一个集群可以包含多个索引，一个索引有多个类型，每个类型有多个文档，每个问的那个有多个字段。<br>一般来说，认为Document是最顶层结构/根对象 序列化成的JSON数据，而对象一般认为是一个JSON结构体，对象还能包含其他对象。<br>元数据主要有3个，_index,_type,_id。</p>
<h2 id="创建">创建</h2><p>创建文档可以使用PUT，也可以使用POST，唯一的区别在于是否由用户提供_id</p>
<pre><code>POST <span class="regexp">/website/blog/</span>
</code></pre><p>使用POST可以由ES自己生成_id，避免由于_id相同导致的碰撞，id为22位的UUID<br>使用</p>
<pre><code>PUT /website/blog/<span class="number">123</span>?op_<span class="built_in">type</span>=create
</code></pre><p>可以直接声明_id，但是如果id已经存在，则会替换旧的数据，_version版本号提高1，_create改为false，如果需要保证是创建而不是更新，可以使用显式的op_type参数，如果冲突，会返回409 Conflict，如果成功，会返回201 Created。<br>也可以使用简化</p>
<pre><code>PUT <span class="regexp">/website/</span>blog<span class="regexp">/123/</span>_create
</code></pre><h2 id="获取">获取</h2><pre><code><span class="comment">GET</span> <span class="comment">/website/blog/123?pretty</span>
</code></pre><p>可以获取文档。<br>参数可选<br>使用pretty可让文档显示的更加美观<br>使用_source可以控制_source字段返回的数据，ES可以仅仅返回用户需要的数据，例如_source=title,如果只使用_source，ES不返回metadata，只返回用户数据。<br>另外可以使用HEAD来确认文档是否存在，当返回为200时文档存在，返回为404时文档不存在</p>
<pre><code>curl -<span class="tag">i</span> -XHEAD http:<span class="comment">//localhost:9200/website/blog/123</span>
</code></pre><h2 id="删除">删除</h2><pre><code><span class="keyword">DELETE</span> <span class="regexp">/website/</span>blog<span class="regexp">/123</span>
</code></pre><p>使用DELETE来删除文档。不管文档是否删除成功，该文档的_version都会自增。</p>
<h2 id="更新">更新</h2><p>更新可以直接使用PUT对已有数据进行更新。<br>也可以使用_update局部更新</p>
<h2 id="搜索">搜索</h2><h3 id="空搜索">空搜索</h3><p>直接使用</p>
<pre><code><span class="title">GET</span> /_search
</code></pre><p>响应内容中有 <code>{took : times , hits : { total : n , hits : [ … ] }}</code><br>Took表示本次请求花费的毫秒，hits表示匹配到的文档。文档中包含一个_score评分</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">	"<span class="attribute">hits</span>" : <span class="value">&#123;</span><br><span class="line">		"<span class="attribute">total</span>" :<span class="value"><span class="number">14</span></span>,</span><br><span class="line">		"<span class="attribute">hits</span>" : <span class="value">[</span><br><span class="line">				&#123;</span><br><span class="line">					"<span class="attribute">_index</span>":<span class="value"><span class="string">"us"</span></span>,</span><br><span class="line">					"<span class="attribute">_type</span>":<span class="value"><span class="string">"tweet"</span></span>,</span><br><span class="line">					"<span class="attribute">_id</span>":<span class="value"><span class="string">"7"</span></span>,</span><br><span class="line">					"<span class="attribute">_score</span>":<span class="value"><span class="number">1</span></span>,</span><br><span class="line">					"<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">								"<span class="attribute">date</span>":	<span class="value"><span class="string">"2014-09-17"</span></span>,</span><br><span class="line">								"<span class="attribute">name</span>":	<span class="value"><span class="string">"John Smith"</span></span>,	</span><br><span class="line">								"<span class="attribute">tweet</span>":<span class="value"><span class="string">"The Query DSL is really powerful and flexible"</span></span>,</span><br><span class="line">								"<span class="attribute">user_id</span>": <span class="value"><span class="number">2</span></span><br><span class="line">								</span>&#125;        </span><br><span class="line">				</span>&#125;,</span><br><span class="line">				... <span class="number">9</span> RESULTS REMOVED ...       </span><br><span class="line">		]</span>,       </span><br><span class="line">		"<span class="attribute">max_score</span>" :   <span class="value"><span class="number">1</span>   </span><br><span class="line">	</span>&#125;</span>,    </span><br><span class="line">	"<span class="attribute">took</span>" :<span class="value"><span class="number">4</span></span>,    </span><br><span class="line">	"<span class="attribute">_shards</span>" : <span class="value">&#123;       </span><br><span class="line">		"<span class="attribute">failed</span>" :<span class="value"><span class="number">0</span></span>,       </span><br><span class="line">		"<span class="attribute">successful</span>" :<span class="value"><span class="number">10</span></span>,       </span><br><span class="line">		"<span class="attribute">total</span>" :<span class="value"><span class="number">10</span>   </span><br><span class="line">	</span>&#125;</span>,</span><br><span class="line">	"<span class="attribute">timed_out</span>" :<span class="value"><span class="literal">false</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>评分为relevance score，在提供了查询条件的情况下，文档按照相关性评分降序排列。<br>_shards表示参数查询的分片数。<br>time_out表示是否超时，如果要求响应速度，可以限制time_out，这样ES会在请求超时前返回收集到的结果</p>
<pre><code>GET /_search?<span class="keyword">timeout</span>=<span class="number">10</span>ms
</code></pre><h3 id="限定搜索">限定搜索</h3><pre><code>/<span class="keyword">index</span>[,<span class="keyword">index</span>]/_search 限制在几个索引间搜索数据
</code></pre><p>也可以使用通配符搜索。/g*/_search，以g开头的index中搜索。</p>
<pre><code>/<span class="keyword">index</span>[,<span class="keyword">index</span>]/<span class="keyword">type</span>[,<span class="keyword">type</span>]/_search 在<span class="keyword">index</span>索引中，搜索<span class="keyword">type</span>中的文档。
</code></pre><h3 id="分页">分页</h3><pre><code>GET /_search?<span class="variable">size=</span><span class="number">5</span>&amp;<span class="variable">from=</span><span class="number">10</span>
</code></pre><h3 id="简单搜索">简单搜索</h3><pre><code>GET /<span class="built_in">index</span>/<span class="keyword">type</span>/search?q=key:<span class="keyword">value</span>
</code></pre><p>表示搜索key字段包含value的文档</p>
<pre><code>+k1:(<span class="literal">v1</span> <span class="literal">v3</span>) -k2:<span class="literal">v2</span> +date:&gt;<span class="number">2014</span>-<span class="number">09</span>-<span class="number">10</span>
</code></pre><p>表示必须含有k1:v1,v3和必须没有k2:v2，时间大于给定时间的文档</p>
<pre><code>GET /<span class="number">_</span>search?q=<span class="keyword">value</span>
</code></pre><p>表示含有value的文档。因为ES会将所有的字段拼接起来，形成一个_all字段，最终被ES索引。</p>
<p>一般搜索结构：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="tag">QUERY_NAME</span>: &#123;</span><br><span class="line">		<span class="tag">FIELD_NAME</span>: &#123;</span><br><span class="line">			<span class="attribute">ARGUMENT</span>: VALUE,</span><br><span class="line">			<span class="attribute">ARGUMENT</span>: VALUE,</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="过滤">过滤</h3><ul>
<li>term : <code>&quot;term&quot;:{ k:v }</code> 主要用于精确匹配，包括bool，日期，数字，未经分析的字符串。</li>
<li>terms : <code>&quot;terms&quot;:{ k:[v1,v2] }</code> 可以用于精确匹配多个值。</li>
<li>range : <code>&quot;range&quot;: { k:{&quot;lte&quot;:20,&quot;gte&quot;:30} }</code> 可以用于指定范围查找数据，范围操作符包含:gt,gte,lt,lte</li>
<li>exists|missing : <code>&quot;exists&quot;:{ &quot;field&quot;:&quot;k&quot; }</code> 这两个过滤语句仅用于已经找到文档后的过滤</li>
<li><p>bool过滤 : </p>
  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bool"</span>: &#123; </span><br><span class="line">	<span class="string">"must"</span>: &#123; </span><br><span class="line">		<span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="string">"should"</span>: [&#123; … &#125;,&#123; … &#125;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以用来合并多个过滤条件查询结果的布尔逻辑。<br>  must表示多个结果的完全匹配，must_not表示多个结果的完全匹配的否定，should表示至少有一个查询条件匹配</p>
</li>
</ul>
<h3 id="查询">查询</h3><ul>
<li>match_all : <code>&quot;match_all&quot;: {}</code> 表示匹配所有文档</li>
<li>match : match是一个标准查询</li>
<li>multi_match : <code>&quot;multi_match&quot;:{ k:v, k:[v,v] }</code> 允许一次查询多个字段</li>
<li><p>bool查询 : </p>
  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bool"</span>: &#123; </span><br><span class="line">	<span class="string">"must"</span>: &#123; </span><br><span class="line">		<span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"how to make millions"</span> &#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  bool查询相比bool过滤多了一部查询_score的步骤</p>
</li>
</ul>
<h3 id="组合查询">组合查询</h3><p>过滤和查询需要放置在对应的context当中，过滤对应filter，查询对应query<br>由于search API中只能使用query语句，所以多重查询中需要使用filtered来包含query和其他过滤语句。<br>例如同时使用match查询和term过滤。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"query"</span>: &#123; </span><br><span class="line">	<span class="string">"filtered"</span>: &#123; </span><br><span class="line">		<span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">k:</span>v &#125; &#125;, </span><br><span class="line">		<span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">k:</span>v &#125; &#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想要匹配所有的文档，可以忽略query语句的match查询，这样filtered会默认补充一个match_all的查询。以下两句效果相同。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"query"</span>: &#123; <span class="string">"filtered"</span>: &#123; <span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123; &#125; &#125; , <span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">k:</span>v &#125; &#125; &#125;</span><br><span class="line"><span class="string">"query"</span>: &#123; <span class="string">"filtered"</span>: &#123; <span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">k:</span>v &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>另外，过滤语句中可以使用query方式代替bool过滤子句。<br>例如 <code>&quot;must_not&quot;: { &quot;query&quot; : { ... } }</code> 但是这种方式使用比较少。</p>
<h3 id="查询检测_-_validate_API">查询检测 - validate API</h3><p>validate API可以用于检测查询语句是否合法。</p>
<pre><code>GET /index/<span class="class"><span class="keyword">type</span>/<span class="title">_validate</span>/<span class="title">query</span> &lt;BODY&gt;</span>
</code></pre><p>如果需要查询具体错误信息，可以加上explain参数,query?explain<br>如果查询语句合法的情况下，explain会针对每一个index返回不同的描述。因为不同的index有不同的映射关系和分析器，例如tweet:powerful这样的查询语句，在一个分析器里可能查询powerful单词，在另外一个使用english分析器的index里就是查询power单词。</p>
<h3 id="排序">排序</h3><h4 id="默认排序：__score">默认排序： _score</h4><p>一般情况下得到的文档都以_score降序排列，相关性高的排在前面。过滤语句不影响_score，如果使用了match_all或者隐式使用了match_all，那么所有的文档的得分都是1.</p>
<h4 id="字段值排序">字段值排序</h4><p>使用sort对字段值进行排序。</p>
<pre><code><span class="collection">{ <span class="string">"query"</span> : <span class="collection">{ … }</span>, <span class="string">"sort"</span>: <span class="collection">{ <span class="string">"date"</span>: <span class="collection">{ <span class="string">"order"</span>: <span class="string">"desc"</span> }</span> }</span> }</span>
</code></pre><p>如果使用了sort排序，那么在没有显式指定track_scores为true的情况下，每一个文档的_score和查询的max_score都不会被计算。<br>因为相关性的计算比较消耗性能，如果指定了排序规则，就没有必要计算了。另外假如排序是date的情况下，date会被转成timestamp用于计算。</p>
<p>如果需要顺序排列时，可以使用简写。 <code>&quot;sort&quot;: &quot;key&quot;</code><br>如果需要多级排序，可以使用： <code>&quot;sort&quot;: [ k1:{&quot;order&quot;: &quot;desc&quot; }, k2:{&quot;order&quot;: &quot;desc&quot; } ]</code><br>如果需要排列的字段是一个数组，那么可以使用min, max, avg 或 sum这些模式来排序。<code>&quot;sort&quot;: { k1:{&quot;order&quot;: &quot;desc&quot;,&quot;mode&quot;: &quot;min&quot; } }</code></p>
<p>如果对于针对全文搜索而使用了analyzer的字段上进行排序，很难得到正确的结果。因此针对这些值，需要重新指定类型。<br>默认：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"tweet"</span>: &#123;</span><br><span class="line">	<span class="string">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">	<span class="string">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"tweet"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"english"</span>,</span><br><span class="line">    <span class="string">"fields"</span>: &#123;</span><br><span class="line">        <span class="string">"raw"</span>: &#123; </span><br><span class="line">            <span class="string">"type"</span>:  <span class="string">"string"</span>,</span><br><span class="line">            <span class="string">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tweet 字段用于全文本的 analyzed 索引方式不变。新增的 tweet.raw 子字段索引方式是 not_analyzed。<br>后面可以使用 <code>&quot;sort&quot;: &quot;tweet.raw&quot;</code> 来对这个字段进行排序。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


      
    
      
        

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/20/30days30tech_1_bower/">
                Bower
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-06-20
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/06/20/30days30tech_1_bower/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/06/20/30days30tech_1_bower/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="什么是Bower">什么是Bower</h2><p>Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。Bower使用flat dependency tree</p>
<h2 id="安装和使用">安装和使用</h2><p>这里使用Ubuntu，安装Nodejs和包管理npm请使用apt-get。由于Ubuntu有个包叫node，所以直接运行bower会提示出错<code>/usr/bin/env: node: 没有那个文件或目录</code>。为了解决这个问题，需要做个软链。另外大部分的依赖包都是从git上面拉取下来的，这都快成为业界规范了，因此再装个git吧。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> nodejs</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> npm</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> git</span><br><span class="line">sudo npm <span class="keyword">install</span> -g bower</span><br><span class="line">//解决node文件不存在的问题</span><br><span class="line">sudo <span class="keyword">ln</span> -s /usr/<span class="keyword">bin</span>/nodejs /usr/<span class="keyword">bin</span>/node</span><br><span class="line">//解决bower没有权限的问题</span><br><span class="line">sudo chown $<span class="keyword">USER</span>:$<span class="keyword">USER</span> ~/.config/configstore/bower-github.yml</span><br><span class="line">//需要运行在非SUDO模式下，否则会有ESUDO错误。</span><br><span class="line">bower <span class="keyword">install</span> jquery</span></span><br></pre></td></tr></table></figure>
<p>缓存目录位于<code>~/.config/configstore/bower_components</code>。可以通过find自行查找<code>find ./ -name bower_components</code></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//列出所有当前路径下的包</span><br><span class="line"><span class="keyword">bower </span>list</span><br><span class="line">//搜索</span><br><span class="line"><span class="keyword">bower </span>search <span class="keyword">bootstrap</span><br><span class="line"></span>//包信息检索</span><br><span class="line"><span class="keyword">bower </span><span class="preprocessor">info</span> <span class="keyword">bootstrap#3.0.0</span><br><span class="line"></span>//初始化创建<span class="keyword">bower.json</span><br><span class="line"></span><span class="keyword">bower </span>init</span><br></pre></td></tr></table></figure>
<p>随后可以开始创建页面。如果当前目录没有出现bower_components这个文件夹，可以重新运行一次bower install package。<br>引用包的路径为<code>bower_components/packagename/dist/filename</code></p>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Learning Bower<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span>&gt;</span>Animate Me!!<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">”background:red;height:100px;width:100px;position:absolute;”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">”text</span>/<span class="attribute">javascript</span>” <span class="attribute">src</span>=<span class="value">”bower_components</span>/<span class="attribute">jquery</span>/<span class="attribute">dist</span>/<span class="attribute">jquery.min.js</span>”&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">”text</span>/<span class="attribute">javascript</span>”&gt;</span><span class="javascript"></span><br><span class="line">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(“button”).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    $(“div”).animate(&#123;left:’<span class="number">250</span>px’&#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><p><a href="http://bower.io/#getting-started" target="_blank" rel="external">http://bower.io/#getting-started</a><br>//这个html的引用路径出错<br><a href="http://blog.fens.me/nodejs-bower-intro/" target="_blank" rel="external">http://blog.fens.me/nodejs-bower-intro/</a></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


      
    
      
        

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/05/11/nagaimichi/">
                漫长的实习求职
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2014-05-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/11/nagaimichi/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/05/11/nagaimichi/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>经历了漫长的3月和4月,终于走完了实习校招季,下面做个小结以后再分别说各个公司</p>
<p>从最早3月初的广研笔试,到最迟4月下旬的WPS笔试,一直到4月23拿到企鹅offer,5月初拿到阿里offer</p>
<p>曾在被网易HR刷掉以后一度想放弃实习,好好蹲宿舍自己看书,网易是我最早走完所有流程的公司,因此也投入了很大的期望,当我得知他们已经签约我却被刷的时候那种失落感无发言表,当然,福无双至祸不单行,网易签约那天也是我广研终面那天,于是我带着绝望的心情去总监面,当他问及我遇到的最难的问题的时候,我轻蔑的说了:没有,都能google到的东西有什么难的,于是我又愉快的被广研刷掉了.</p>
<p>在4月份来回骑行深圳以后,我才振作起来,开始把面试官问道的一切我不知道的内容搞懂,确定自己的方向并且为面试做准备.在拿到腾讯offer后轻松迎战金山和阿里,由于STL基础实在不足被金山刷掉,阿里那边则飞快的完成面试,因为那天也是我腾讯签约的日子,结果我为了在阿里面试迟到了1个多小时.直到签约结束我才知道,原来只要和HR说自己已经拿到腾讯offer,就可以获得当场签约阿里的特殊优待,可惜我知道的太晚了.</p>
<p>好,回到总结.按照最后一场面试的时间排序:</p>
<ol>
<li>腾讯广研:走完面试流程-笔试-初面-项目-总监面-在小组都收到拒信的情况下我被默拒</li>
<li>网易游戏TTT:走完面试流程-笔试-技术一面-技术二面-HR面-被拒</li>
<li>腾讯深圳:走完面试流程-笔试-技术一面-技术二面-技术三面-HR面-OFFER</li>
<li>金山WPS:笔试-技术一面-被拒</li>
<li>阿里巴巴:走完面试流程-笔试-技术一面-技术/HR同时二面-OFFER</li>
</ol>
<p>按照笔试时间排序: 广研-网易-腾讯-阿里-金山</p>
<p>笔试难易度排行:网易游戏阿里巴巴广研腾讯金山WPS</p>
<p>但是就考试压力来说,阿里巴巴要和网易游戏换个位,阿里选错倒扣.</p>
<h2 id="笔试">笔试</h2><p>先从基础说起,其实笔试不需要非常熟悉的掌握那些知识,毕竟我们是在和别人比,因此只要能够比周围大部分都高那就足够了,不需要追求一定要拿高分,反正面试的时候不见得因为高分就有优势.</p>
<h3 id="广研">广研</h3><p>(对了,13年和14年题目基本一致,15年如果你准备去广研并且对自己笔试没信心,务必请先搜索</p>
<ol>
<li>计算ackerman(3,3),当然只有基础公式没有每一层的公式,只要花点时间就可以解决</li>
<li>catalan数,求1,2,3,4,5顺序入栈那么出栈有几种排列.</li>
<li>26进制转换(手写代码,当然相当简单,而且实际上广研评分不计代码题</li>
<li>SQL语句在数据库中的执行顺序(GROUP/HAVING<br>其他的题目真的很基础,例如TCP/IP,OSI模型,排序稳定性,排序时间复杂度,排序空间复杂度,二分查找手写或者修改<br>数据库,还有#define.</li>
</ol>
<p>还有稍微问到一些LINUX相关的内容,例如time的结果:real,sys,user的意义,基础命令.目录结构,</p>
<p>此外还有一些计算机相关但不是非必学的内容,例如windows栈大小,这些只能靠平时积累(其实还是考前搜一下历年题目比较靠谱)</p>
<h3 id="网易游戏TTT:">网易游戏TTT:</h3><p>网易游戏的笔试题是我做过的题目里面最难的,先亮一道内存对齐的题目吧:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line"> <span class="keyword">short</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> node t;</span><br><span class="line"> t.b=<span class="number">0x0102</span>;</span><br><span class="line"> <span class="keyword">char</span> * p = (<span class="keyword">char</span>*)</span><br><span class="line"> <span class="built_in">cout</span>(<span class="keyword">int</span>)*(p+<span class="number">4</span>);<span class="comment">//写出结果</span></span><br></pre></td></tr></table></figure>
<p>此外还有写出写出绕Y轴旋转的旋转矩阵,C指针的判断和处理,二分查找,快排,短路运算符及括号内运算次序,</p>
<p>这样的宏有什么错? <code>#define assert(e) if(!e) assert_error(_ERROR_LINE)</code>, (实际上就是e外面缺括号)</p>
<p>类继承以及类继承以后对ctor/dtor的调用顺序,linux的fork执行顺序,bash的标准重定向(例如 ./program file 2&amp;1 )</p>
<p>还有一些编程题,大部分都是N选1来写,写自己最熟悉的代码就好,约瑟夫环,纸牌顺子判断,程序改错</p>
<p>另外需要注意的是试卷分为两部分,基础部分如果分数不达标就直接PASS不看后面的题目</p>
<h3 id="腾讯/金山">腾讯/金山</h3><p>为什么放在一起写?因为这两个实在太简单了,简单的一个半小时的试卷我都在40分终左右交卷走人</p>
<p>另外腾讯笔试签了保密协议,所以大概说个方向:</p>
<p>笔试中规中矩,相比其他科技公司的笔试,腾讯笔试更像研究生考试多一些(什么,你说我都没考过研究生怎么知道像研究生考试?)</p>
<p>总而言之,涉及到各种基础题,计算机网络,操作系统,甚至连js都有,更别说C/C++了(反正还是注意指针,char,类等基本只是).不过其实只要上课有认真学,自己也稍有编码的话基本不成问题</p>
<p>金山WPS就更搞笑了,题目简单的无力吐槽,我觉得大二学生也能轻松过</p>
<p>大题都非常简单,例如对一个student的类进行函数补全及二次封装,几个长方形堆叠起来以后计算至少要多大的长方形才能覆盖住前面的长方形(提供每个长方形的x,y,w,h)</p>
<p>对SHAPE类,TRIANGLE,LINE类进行简化,这简直就是大一都会写的题.</p>
<p>最难的是最后一题,不过可以只写伪代码:根据字典(KV对)来进行翻译,最好能够实现最长匹配,例如(go 去 , home 回家 , go home 回家,这样遇到go home翻译为回家而不是去家),扩展是逆向翻译</p>
<h3 id="阿里巴巴">阿里巴巴</h3><p>对于选错倒扣这种考试方式,实在太考验心理了</p>
<p>du/df的区别,多路归并复杂度,快排复杂度,概率论,几道IQ题,跳跃链表求单次查找的平均复杂度,如何做均衡负载防止SPOF和保证健壮性.修改错误的二分查找代码.malloc,根据树的度求叶子数.50fps的640*360的24位真彩色视频能否在24Mpbs的蓝牙下传输,C的malloc/calloc/realloc.</p>
<p>有个比较有意思的题目:</p>
<p>某次比赛,按照强弱编号1-8.当编号强弱对比小于等于2的时候可能爆冷.先进行1/4,然后1/2,然后决赛,请问哪个获胜几率最高.</p>
<h2 id="面试">面试</h2><p>面试只挑个别的来讲讲,很多大同小异的就没有必要复述了</p>
<p>比较常见的问题(一般都会根据简历来问,所以项目不熟悉请不要乱写):</p>
<ol>
<li>介绍自己写过的比较得意的项目,详细叙述一下系统的结构以及你所负责的区域</li>
<li>你在项目中遇到了哪些困难,如何解决的(这个也算是广研总监唯一问的一道题)</li>
<li>最近有看什么技术书籍,有什么收获,挑几个用自己的语言描述一下问题及解决方案</li>
</ol>
<p>有兴趣的可以看看一篇不错的文章 <a href="http://www.cnblogs.com/shaohz2014/p/3690808.html" target="_blank" rel="external">不是技术牛人，如何拿到国内IT巨头的Offer</a></p>
<p>每个公司都有自己不同的侧重方向,所以请找准重点.</p>
<p>以我后台开发的角度看,腾讯非常侧重项目,大片的时间叙述项目的结构和处理.网易侧重基础,而且问的很深入,无论是C/C++编程方面还是数据库,对项目也比较有兴趣.<br>阿里问的很均衡,一部分算法,一部分项目,特别喜欢问EPOLL,金山WPS除了问底层实现就是STL底层实现</p>
<p>对了,注意准备好自我介绍,部分面试官会要求自我介绍,但是也有很多面试官不让我自我介绍,比例大概在2:3的样子.</p>
<h3 id="腾讯技术3面(BOSS面):">腾讯技术3面(BOSS面):</h3><p>腾讯面试3场分了3天,中间间隔N天</p>
<p>3面的面试官是我未来部门的BOSS,他也是在我十几场面试生涯中,唯一一个做了自我介绍的面试官</p>
<p>然后开头就告诉我,会从5个方向来进行这次面试</p>
<ol>
<li>设计与开发:请基于一种协议(TCP/HTTP etc)设计一个可扩展的网络协议,用登陆来作样例解释这个协议的字段和方法</li>
<li>项目经历:介绍项目系统结构,遇到困难点和如何解决</li>
<li>计算机基础:介绍数组,链表,树,哈希表,TCP.IP.UDP.HTTP的特点.字符编码的转换UNICODE,UTF-8,UCS-2,GBK,GB18030</li>
<li>业界视野:互联网产品有什么特点,与传统产品有什么不同</li>
<li>生涯规划:未来的发展路线</li>
</ol>
<h3 id="网易TTT:">网易TTT:</h3><p>技术一面和技术二面在一个早上内结束,如果一面失败就不会有机会二面</p>
<ol>
<li>如何在一个语句内执行”有就更新没有就插入”. 实际上就是MYSQL扩展语法 INSERT … ON DUPLICATE KEY UPDATE …</li>
<li>apache和mod-php之间怎么传输数据</li>
<li>CI底层如何路由</li>
<li>SOCKET的服务原语,实现,使用</li>
<li>C++基础,例如复制构造函数,深浅拷贝,虚函数表的实现, struct和class的区别(本质只有访问权限的区别),NEW和MALLOC的区别</li>
<li>AJAX实现原理和机制,JS的常用方法</li>
<li>数据库底层,例如分快读取,行储存,列储存,NOSQL和SQL等</li>
</ol>
<h3 id="金山WPS:">金山WPS:</h3><p>因为面试的时候我已经有了企鹅的offer,所以只是抱着经历人生的想法去的.不过这个面试官让我对金山的印象瞬间提高了几个档次<br>问题:</p>
<ol>
<li>请问你用过智能指针吗?先讲一下用法,然后描述一下底层数据结构及实现(我讲了share_ptr)</li>
<li>请问你用过vector吗?讲一下底层实现然后手写一下用iter反转vector的代码</li>
<li>介绍一下常见的数据结构</li>
<li>手写memcpy,并问了需要注意什么地方(其实就是防止内存覆盖)</li>
<li>还有一些其他的一些算法和STL源代码,已经记不太清了</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


      
    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/aniki.png" alt="slixurd" />
          <p class="site-author-name">slixurd</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/slixurd" target="_blank">Github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/slixurd" target="_blank">Twitter</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">slixurd</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  

    
      
    

    <script type="text/javascript">
      var disqus_shortname = 'slixurd';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
    </script>
  





  
  

</body>
</html>
